<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>RV.helperfunctions.visualization_helperfunctions API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>RV.helperfunctions.visualization_helperfunctions</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from scipy.signal import welch

from plotly.graph_objs import Figure, Scattergl

from mne.viz.topomap import _get_pos_outlines

from helperfunctions.annotation_helperfunctions import get_annotations
import constants as c
import globals


def get_channel_locations_plot(raw):
    &#34;&#34;&#34;Generates channel-topography plot of given raw object.

    Args:
        raw (mne.io.Raw): Raw object to get channel locations from.

    Returns:
        plotly.graph_objs.Figure: Plot of channel-topography.
    &#34;&#34;&#34;
    # Get channel locations through MNE
    if raw.info[&#39;dig&#39;]:
        pos, outlines = _get_pos_outlines(raw.info, np.arange(len(raw.info[&#39;chs&#39;])), &#39;auto&#39;)
        
        head_coordinates = outlines[&#39;mask_pos&#39;]
        head_markers = []
        head_markers.append(min(head_coordinates[0]))
        head_markers.append(max(head_coordinates[0]))
        head_markers.append(min(head_coordinates[1]))
        head_markers.append(max(head_coordinates[1]))
        print(head_markers)
    else:
        pos = np.array([])
        outlines = []
        head_markers = []
    # print(pos)
    print(outlines)
    
    chs = raw.info[&#39;chs&#39;]
    channel_coordinates = pos  # np.empty((len(chs), 2))  # manual
    channel_names = []

    for index, channel in enumerate(chs):
        # channel_coordinates[index] = channel[&#39;loc&#39;][:2]  # manual
        channel_names.append(channel[&#39;ch_name&#39;])

    # Optional to scale channel locations
    # channel_coordinates = channel_coordinates * 1000

    topography_plot = Figure()

    if channel_coordinates.size &gt; 0:
        for channel in range(len(channel_names)):
            topography_plot.add_trace(
                Scattergl(
                    x=[channel_coordinates[channel, 0]],
                    y=[channel_coordinates[channel, 1]],
                    customdata=[channel_names[channel]],
                    mode=&#34;markers+text&#34;,
                    name=channel_names[channel],
                    text=channel_names[channel],
                    textposition=&#34;bottom center&#34; if channel_coordinates[channel, 1] &lt;= 0 else &#39;top center&#39;,
                    hovertemplate=&#39;&lt;b&gt;%{fullData.name}&lt;/b&gt;&#39; + &#39;&lt;extra&gt;&lt;/extra&gt;&#39;,
                    # marker=dict(color=&#39;#4796c5&#39;)
                )
            )
        
        if head_markers:
            topography_plot.add_shape(
                type=&#34;circle&#34;,
                xref=&#34;x&#34;,
                yref=&#34;y&#34;,
                x0=head_markers[0],
                x1=head_markers[1],
                y0=head_markers[2],
                y1=head_markers[3],
                line_color=&#34;black&#34;,
            )

    topography_plot.update_layout(
        dragmode=&#39;select&#39;,
        showlegend=False,
        clickmode=&#39;event+select&#39;
    )
    
    topography_plot.update_yaxes(
        scaleanchor = &#34;x&#34;,
        scaleratio = 1,
    )

    # topography_plot.update_xaxes(
    #     # title_text=&#39;Time (in sec)&#39;
    #     # showgrid=True,
    #     # zeroline=False,
    #     # constrain=&#39;domain&#39;,
    #     # range=(-0.2, 10.2),  # Start x-axis range to show approx. 10 seconds
    # )

    return topography_plot

def get_power_spectrum_plot(f, Pxx_den):
    &#34;&#34;&#34;Generates power spectrum plot.

    Args:
        f (array): Sample frequencies.
        Pxx_den (array): Power densities.

    Returns:
        plotly.graph_objs.Figure: Plot of power spectrum.
    &#34;&#34;&#34;
    fig = Figure()

    fig.add_trace(
        Scattergl(
            x=f,
            y=Pxx_den,
            hovertemplate=&#39;Frequency (in Hz)=%{x:.2f}, Power density=%{y:.2f}&#39; + &#39;&lt;extra&gt;&lt;/extra&gt;&#39;,
            marker=dict(color=&#39;#4796c5&#39;)
        )
    )

    fig.update_layout(
        xaxis=dict(
            title_text=&#39;Frequencies (in Hz)&#39;,
        ),
        yaxis=dict(
            title_text=&#39;Power density&#39;
        ),
    )

    return fig

def calc_power_spectrum(sample_rate, selected_data):
    &#34;&#34;&#34;Calculate power spectrum of selected data using SciPy&#39;s welch method.

    Args:
        sample_rate (float): Sample rate of selected data.
        selected_data (array): Selected data to calculate power spectrum of.

    Returns:
        tuple(array, array): Tuple of sample frequencies and corresponding power densities.
    &#34;&#34;&#34;
    f, Pxx_den = welch(selected_data, sample_rate)

    return f, Pxx_den

def get_most_prominent_freq(f, Pxx_den):
    &#34;&#34;&#34;Calculate most prominent frequency of selected data.

    Args:
        f (array): Sample frequencies.
        Pxx_den (array): Power densities.

    Returns:
        float: Frequency with highest density.
    &#34;&#34;&#34;
    temp_list = Pxx_den.tolist()
    maximum_peak = temp_list.index(Pxx_den.max())
    maximum_peak_value = f[maximum_peak]
    # print(maximum_peak_value)

    return maximum_peak_value

def _get_scaling(EEG_scale):
    &#34;&#34;&#34;Calculates scaling factor to multiply data with for given scale.

    Args:
        EEG_scale (float): Desired scale of data. Defaults to 1e-6.

    Returns:
        float: Scaling factor to multiply data with.
    &#34;&#34;&#34;
    if EEG_scale:
        temp = EEG_scale
        temp_string = str(EEG_scale)

        if &#39;e&#39; in temp_string:
            e_index = temp_string.index(&#39;e&#39;)
            zeros = int(temp_string[e_index + 2:])
            temp *= 10 ** zeros
            temp *= 10 ** zeros
        else:
            zeros = 0
            while temp &lt; 1:
                temp *= 10
                zeros += 1
            temp *= 10 ** zeros

        scaling_factor = temp

        # print(&#39;Apply custom scaling {}&#39;.format(scaling_factor))
    else:
        scaling_factor = c.CONVERSION_VALUE_VOLTS_TO_MICROVOLTS
        
    return scaling_factor
        
def _get_offset(channel_offset):
    &#34;&#34;&#34;Returns offset factor to multiply data with.

    Args:
        channel_offset (int): Offset between channels. Defaults to 40 (μV).

    Returns:
        int: Offset factor to multiply data with.
    &#34;&#34;&#34;
    if channel_offset or channel_offset == 0:
        offset_factor = channel_offset
    else:
        offset_factor = c.DEFAULT_Y_AXIS_OFFSET
        
    return offset_factor

def _get_time(EEG_data, sample_frequency):
    &#34;&#34;&#34;Calculates timescale and recording length of given EEG data.

    Args:
        EEG_data (array): EEG data.
        sample_frequency (float): Sample frequency of data.

    Returns:
        tuple(array, float): Array of all timepoints, recording length.
    &#34;&#34;&#34;
    # Create time-scale for x-axis of visualization
    timestep = 1 / sample_frequency

    timescale = [timestep * i for i in range(EEG_data.shape[0])]

    recording_length = float(timescale[-1] + timestep)
    print(&#39;Length of recording in seconds: {}&#39;.format(recording_length))
    
    return timescale, recording_length

def _get_plotting_data(raw, file_name, selected_channel_names, EEG_scale, channel_offset, model_output=[], model_channels=[]):
    &#34;&#34;&#34;Generates dict holding all relevant data from raw object and model outputs for plotting.

    Args:
        raw (mne.io.Raw): Raw object to get data from.
        file_name (string): File-name.
        selected_channel_names (list): List of strings of selected channel names to plot.
        EEG_scale (float): Desired scaling.
        channel_offset (int): Desired channel offset.
        model_output (list, optional): List of arrays of model outputs. Defaults to [].
        model_channels (list, optional): List of lists of strings of channel names model output is based on. Defaults to [].

    Returns:
        dict: Dict holding all relevant data from raw object and model outputs for plotting.
    &#34;&#34;&#34;
    plotting_data = {&#39;EEG&#39;: {}, &#39;model&#39;: [], &#39;plot&#39;: {}}
    
    plotting_data[&#39;EEG&#39;][&#39;file_name&#39;] = file_name

    plotting_data[&#39;EEG&#39;][&#39;scaling_factor&#39;] = _get_scaling(EEG_scale)
    plotting_data[&#39;plot&#39;][&#39;offset_factor&#39;] = _get_offset(channel_offset)

    if selected_channel_names:
        check = all(channel in raw.ch_names for channel in selected_channel_names)
        if check:
            plotting_data[&#39;EEG&#39;][&#39;EEG_data&#39;] = np.transpose(raw.get_data(selected_channel_names))
            plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;] = selected_channel_names
    else:
        print(&#39;Displaying all channels&#39;)
        plotting_data[&#39;EEG&#39;][&#39;EEG_data&#39;] = np.transpose(raw.get_data())
        plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;] = raw.ch_names

    plotting_data[&#39;EEG&#39;][&#39;timescale&#39;], plotting_data[&#39;EEG&#39;][&#39;recording_length&#39;] = _get_time(plotting_data[&#39;EEG&#39;][&#39;EEG_data&#39;], raw.info[&#39;sfreq&#39;])

    # Calculate offset for y-axis
    offset_EEG = plotting_data[&#39;EEG&#39;][&#39;EEG_data&#39;].copy() 
    offset_EEG = offset_EEG * plotting_data[&#39;EEG&#39;][&#39;scaling_factor&#39;]
    
    default_channel_colors = []
    highlighted_channel_colors = []
    channel_visibility = []

    for channel_index in range(offset_EEG.shape[1]):
        # Calculate offset for y-axis
        offset_EEG[:, channel_index] = offset_EEG[:, channel_index] + ((plotting_data[&#39;plot&#39;][&#39;offset_factor&#39;]) * (len(plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;]) - 1 - channel_index))  # First channel goes to top of the plot
        
        # Channel colors
        if plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;][channel_index] in raw.info[&#39;bads&#39;]:
            default_channel_colors.append(c.BAD_CHANNEL_COLOR)
            channel_visibility.append(False)
        else:
            default_channel_colors.append(&#39;black&#39;)
            channel_visibility.append(True)

        model_channel = False
        for model in range(len(model_channels)):
            if model_channels[model]:
                if plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;][channel_index] in model_channels[model]:
                    model_channel = True
            
        if model_channel:
            highlighted_channel_colors.append(&#39;blue&#39;)
        elif plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;][channel_index] in raw.info[&#39;bads&#39;]:
            highlighted_channel_colors.append(c.BAD_CHANNEL_COLOR)
        else:
            highlighted_channel_colors.append(&#39;black&#39;)
            
    plotting_data[&#39;EEG&#39;][&#39;offset_EEG_data&#39;] = offset_EEG
            
    for model_index, model_array in enumerate(model_output):
        default_channel_colors.append(model_array)
        highlighted_channel_colors.append(model_array)
        
        plotting_data[&#39;model&#39;].append({})
        plotting_data[&#39;model&#39;][model_index][&#39;model_data&#39;] = model_array
        plotting_data[&#39;model&#39;][model_index][&#39;model_channels&#39;] = model_channels[model_index]

        plotting_data[&#39;model&#39;][model_index][&#39;model_timescale&#39;] = np.linspace(0, plotting_data[&#39;EEG&#39;][&#39;recording_length&#39;], num=model_array.shape[0])

        plotting_data[&#39;model&#39;][model_index][&#39;offset_model_data&#39;] = [-((2 + model_index) * (plotting_data[&#39;plot&#39;][&#39;offset_factor&#39;])) for i in range(len(plotting_data[&#39;model&#39;][model_index][&#39;model_timescale&#39;]))]
    
    plotting_data[&#39;EEG&#39;][&#39;default_channel_colors&#39;] = default_channel_colors
    plotting_data[&#39;EEG&#39;][&#39;highlighted_channel_colors&#39;] = highlighted_channel_colors
    plotting_data[&#39;EEG&#39;][&#39;channel_visibility&#39;] = channel_visibility
    
    y_ticks_model_output = np.arange((-len(model_output) - 1), -1)
    y_ticks_channels = np.arange(0, len(plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;]))
    y_ticks = np.concatenate((y_ticks_model_output, y_ticks_channels))
    y_ticks = y_ticks * (plotting_data[&#39;plot&#39;][&#39;offset_factor&#39;])
    
    plotting_data[&#39;plot&#39;][&#39;y_ticks&#39;] = y_ticks.copy()

    y_tick_labels = [channel_name for channel_name in plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;]]
    for model_id in range(len(model_output)):
        y_tick_labels.append(&#39;M{}&#39;.format(model_id))
    y_tick_labels.reverse()
    
    plotting_data[&#39;plot&#39;][&#39;y_tick_labels&#39;] = y_tick_labels.copy()
            
    return plotting_data

def get_EEG_figure(file_name, raw, selected_channel_names, EEG_scale=None, channel_offset=None, model_output=None, model_channels=[], use_slider=False):
    &#34;&#34;&#34;Generates initial EEG figure.

    Args:
        file_name (string): File name.
        raw (mne.io.Raw): Raw object to plot data from.
        selected_channel_names (list): List of strings of selected channel names to plot.
        EEG_scale (float): Desired scaling.
        channel_offset (int): Desired channel offset.
        model_output (list, optional): List of arrays of model outputs. Defaults to [].
        model_channels (list, optional): List of lists of strings of channel names model output is based on. Defaults to [].
        use_slider (bool, optional): Whether or not to activate view-slider. Defaults to False.

    Returns:
        plotly.graph_objs.Figure: Plot of EEG data.
    &#34;&#34;&#34;
    fig = Figure()
    
    plotting_data = _get_plotting_data(raw, file_name, selected_channel_names, EEG_scale, channel_offset, model_output, model_channels)
    globals.plotting_data = plotting_data.copy()    
    
    fig = get_EEG_plot(plotting_data, globals.x0, globals.x1, use_slider=use_slider)

    return fig

def get_EEG_plot(plotting_data, x0, x1, use_slider=False):
    &#34;&#34;&#34;Generates EEG plots.

    Args:
        plotting_data (dict): Dict holding all relevant data from raw object and model outputs for plotting.
        x0 (float): X-coordinate (in sec) to start plot.
        x1 (float): X-coordinate (in sec) to end plot.
        use_slider (bool, optional): Whether or not to activate view-slider. Defaults to False.

    Returns:
        plotly.graph_objs.Figure: Plot of EEG data.
    &#34;&#34;&#34;
    fig = Figure()
    
    index_0 = None
    index_1 = None
    
    for index, timepoint in enumerate(plotting_data[&#39;EEG&#39;][&#39;timescale&#39;]):
        if timepoint &gt; x0:
            index_0 = index
            break
        
    for index, timepoint in enumerate(plotting_data[&#39;EEG&#39;][&#39;timescale&#39;]):
        if timepoint &gt; x1:
            index_1 = index
            break
    
    for channel_index in range(plotting_data[&#39;EEG&#39;][&#39;offset_EEG_data&#39;].shape[1]):      
        fig.add_trace(
            Scattergl(
                x=plotting_data[&#39;EEG&#39;][&#39;timescale&#39;][index_0:index_1],
                y=plotting_data[&#39;EEG&#39;][&#39;offset_EEG_data&#39;][index_0:index_1, channel_index],
                marker=dict(color=plotting_data[&#39;EEG&#39;][&#39;default_channel_colors&#39;][channel_index], size=0.1),
                name=plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;][channel_index],
                customdata=plotting_data[&#39;EEG&#39;][&#39;EEG_data&#39;][index_0:index_1, channel_index] * plotting_data[&#39;EEG&#39;][&#39;scaling_factor&#39;],  # y-data without offset
                hovertemplate=&#39;&lt;b&gt;%{fullData.name}&lt;/b&gt; | Time (in sec)=%{x:.2f}, Amplitude (in μV)=%{customdata:.3f}&#39; + &#39;&lt;extra&gt;&lt;/extra&gt;&#39; if not plotting_data[&#39;EEG&#39;][&#39;scaling_factor&#39;] else &#39;&lt;b&gt;%{fullData.name}&lt;/b&gt; | Time (in sec)=%{x:.2f}, Amplitude (scaled)=%{customdata:.3f}&#39; + &#39;&lt;extra&gt;&lt;/extra&gt;&#39;,
                mode=&#39;lines+markers&#39;
            )
        )

    model_index_0 = None
    model_index_1 = None

    # Model predictions
    for model_index in range(len(plotting_data[&#39;model&#39;])):
        for index, timepoint in enumerate(plotting_data[&#39;model&#39;][model_index][&#39;model_timescale&#39;]):
            if timepoint &gt; x0:
                model_index_0 = index
                break
            
        for index, timepoint in enumerate(plotting_data[&#39;model&#39;][model_index][&#39;model_timescale&#39;]):
            if timepoint &gt; x1:
                model_index_1 = index
                break

        fig.add_trace(
            Scattergl(
                x=plotting_data[&#39;model&#39;][model_index][&#39;model_timescale&#39;][model_index_0:model_index_1],
                y=plotting_data[&#39;model&#39;][model_index][&#39;offset_model_data&#39;][model_index_0:model_index_1],
                marker=dict(
                    size=10,
                    cmax=1,
                    cmin=0,
                    color=plotting_data[&#39;model&#39;][model_index][&#39;model_data&#39;][model_index_0:model_index_1],
                    # colorbar=dict(
                    #     title=&#39;Colorbar&#39;,
                    #     yanchor=&#34;top&#34;, 
                    #     y=1, 
                    #     x=1
                    # ),
                    colorscale=&#39;RdBu_r&#39;
                ),
                name=&#39;M{}&#39;.format(model_index),
                mode=&#39;markers&#39;,
                customdata=plotting_data[&#39;model&#39;][model_index][&#39;model_data&#39;][model_index_0:model_index_1],
                hovertemplate=&#39;Time=%{x:.2f}, Prediction=%{customdata:.2f}&lt;extra&gt;&lt;b&gt;%{fullData.name}&lt;/b&gt;&lt;/extra&gt;&#39;
            )
        )
    
    longest_channel_name_length = len(max(plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;], key=len))

    fig.update_layout(
        plot_bgcolor=&#39;#fafafa&#39;,
        paper_bgcolor=&#39;#dfdfdf&#39;,
        title=dict(
            text=plotting_data[&#39;EEG&#39;][&#39;file_name&#39;],
            y=0.98,
            x=0.5 if not plotting_data[&#39;model&#39;] else 0.6,
            xanchor=&#39;center&#39;,
            yanchor=&#39;top&#39;
        ),
        xaxis=dict(
            # title_text=&#39;Time (in sec)&#39;,
            rangeslider=dict(
                visible=True if use_slider else False,
                thickness=0.04
            ),
            type=&#34;linear&#34;,
        ),

        legend=dict(
            # itemwidth=30
            # orientation=&#34;h&#34;,
            # yanchor=&#34;bottom&#34;,
            # y=1,
            # xanchor=&#34;left&#34;,
            x=1.01
        ),

        autosize=False,
        margin=dict(
            autoexpand=False,
            l=longest_channel_name_length * 6 + 15,  #30
            r=longest_channel_name_length * 6 + 80,  #115
            # b=0,
            t=50,
            pad=5,
        ),

        dragmode=&#39;drawrect&#39;,
        newshape=dict(
            fillcolor=&#39;red&#39;,
            opacity=0.6,
            drawdirection=&#39;vertical&#39;,
            layer=&#39;below&#39;,
            line_width=0
        ),
    )

    fig.update_yaxes(
        tickmode=&#39;array&#39;,
        tickvals=plotting_data[&#39;plot&#39;][&#39;y_ticks&#39;],
        ticktext=plotting_data[&#39;plot&#39;][&#39;y_tick_labels&#39;],
        showgrid=False,
        zeroline=False,
        fixedrange=False,
        range=((-(2 + len(plotting_data[&#39;model&#39;])) * (c.DEFAULT_Y_AXIS_OFFSET)), ((len(plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;]) + 1) * (c.DEFAULT_Y_AXIS_OFFSET)))  # Start y-axis range to cut off peaks
    )
    fig.update_xaxes(
        # title_text=&#39;Time (in sec)&#39;
        showgrid=True,
        zeroline=False,
        constrain=&#39;domain&#39;,
        range=(x0, x1) if not use_slider else (x0, x0 + 11),  # Start x-axis range to show approx. 10 seconds
    )

    # Add annotations
    marked_annotations = get_annotations(globals.raw)

    print(marked_annotations)
    
    for annotation in marked_annotations:
        # if not ((annotation[0] &lt; globals.x0 and annotation[1] &lt; globals.x0) or (annotation[0] &gt; globals.x1 and annotation[1] &gt; globals.x1)):
        fig.add_vrect(
            editable=True,
            x0=annotation[0],
            x1=annotation[1],
            fillcolor=&#39;red&#39;,
            opacity=0.6,
            layer=&#39;below&#39;,
            line_width=0
        )
    
    if plotting_data[&#39;model&#39;]:
        plotting_data[&#39;EEG&#39;][&#39;default_channel_colors&#39;][-1] = plotting_data[&#39;EEG&#39;][&#39;default_channel_colors&#39;][-1][index_0:index_1]
        plotting_data[&#39;EEG&#39;][&#39;highlighted_channel_colors&#39;][-1] = plotting_data[&#39;EEG&#39;][&#39;highlighted_channel_colors&#39;][-1][index_0:index_1]
    
    fig.update_layout(
        updatemenus=list([
            dict(
                buttons=list([
                    dict(label=&#34;Reset time-axis&#34;,  
                        method=&#34;relayout&#34;, 
                        args=[{
                            &#34;xaxis.range[0]&#34;: x0,
                            &#34;xaxis.range[1]&#34;: x1 if not use_slider else x0 + 11,
                        }]
                    ),
                    dict(label=&#34;Reset channel-axis&#34;,  
                        method=&#34;relayout&#34;, 
                        args=[{
                            &#34;yaxis.range[0]&#34;: (-(2 + len(plotting_data[&#39;model&#39;])) * (c.DEFAULT_Y_AXIS_OFFSET)),
                            &#34;yaxis.range[1]&#34;: ((len(plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;]) + 1) * (c.DEFAULT_Y_AXIS_OFFSET))
                        }]
                    ),
                    dict(label=&#39;Hide/show bad channels&#39;,
                        method=&#39;restyle&#39;,
                        args2=[{&#39;visible&#39;: True}],
                        args=[{&#39;visible&#39;: plotting_data[&#39;EEG&#39;][&#39;channel_visibility&#39;]}]
                    ),
                    dict(label=&#39;Highlight model-channels&#39;,
                        method=&#39;restyle&#39;,
                        args2=[{&#39;marker.color&#39;: plotting_data[&#39;EEG&#39;][&#39;default_channel_colors&#39;]}],
                        args=[{&#39;marker.color&#39;: plotting_data[&#39;EEG&#39;][&#39;highlighted_channel_colors&#39;]}],
                        visible=True if plotting_data[&#39;model&#39;] else False
                    ),
                ]),
                direction = &#39;left&#39;,
                # active=4,
                # pad = {&#39;l&#39;: 100, &#39;t&#39;: 10},
                showactive = False,
                type = &#39;buttons&#39;,
                xanchor = &#39;left&#39;,
                yanchor = &#39;top&#39;,
                x = 0,
                y = 1.08,
                bgcolor = &#39;#fafafa&#39;,
                bordercolor = &#39;#c7c7c7&#39;
            )
        ])
    )

    return fig</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="RV.helperfunctions.visualization_helperfunctions.calc_power_spectrum"><code class="name flex">
<span>def <span class="ident">calc_power_spectrum</span></span>(<span>sample_rate, selected_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate power spectrum of selected data using SciPy's welch method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sample_rate</code></strong> :&ensp;<code>float</code></dt>
<dd>Sample rate of selected data.</dd>
<dt><strong><code>selected_data</code></strong> :&ensp;<code>array</code></dt>
<dd>Selected data to calculate power spectrum of.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>tuple(array, array): Tuple of sample frequencies and corresponding power densities.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calc_power_spectrum(sample_rate, selected_data):
    &#34;&#34;&#34;Calculate power spectrum of selected data using SciPy&#39;s welch method.

    Args:
        sample_rate (float): Sample rate of selected data.
        selected_data (array): Selected data to calculate power spectrum of.

    Returns:
        tuple(array, array): Tuple of sample frequencies and corresponding power densities.
    &#34;&#34;&#34;
    f, Pxx_den = welch(selected_data, sample_rate)

    return f, Pxx_den</code></pre>
</details>
</dd>
<dt id="RV.helperfunctions.visualization_helperfunctions.get_EEG_figure"><code class="name flex">
<span>def <span class="ident">get_EEG_figure</span></span>(<span>file_name, raw, selected_channel_names, EEG_scale=None, channel_offset=None, model_output=None, model_channels=[], use_slider=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates initial EEG figure.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>string</code></dt>
<dd>File name.</dd>
<dt><strong><code>raw</code></strong> :&ensp;<code>mne.io.Raw</code></dt>
<dd>Raw object to plot data from.</dd>
<dt><strong><code>selected_channel_names</code></strong> :&ensp;<code>list</code></dt>
<dd>List of strings of selected channel names to plot.</dd>
<dt><strong><code>EEG_scale</code></strong> :&ensp;<code>float</code></dt>
<dd>Desired scaling.</dd>
<dt><strong><code>channel_offset</code></strong> :&ensp;<code>int</code></dt>
<dd>Desired channel offset.</dd>
<dt><strong><code>model_output</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>List of arrays of model outputs. Defaults to [].</dd>
<dt><strong><code>model_channels</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>List of lists of strings of channel names model output is based on. Defaults to [].</dd>
<dt><strong><code>use_slider</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to activate view-slider. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly.graph_objs.Figure</code></dt>
<dd>Plot of EEG data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_EEG_figure(file_name, raw, selected_channel_names, EEG_scale=None, channel_offset=None, model_output=None, model_channels=[], use_slider=False):
    &#34;&#34;&#34;Generates initial EEG figure.

    Args:
        file_name (string): File name.
        raw (mne.io.Raw): Raw object to plot data from.
        selected_channel_names (list): List of strings of selected channel names to plot.
        EEG_scale (float): Desired scaling.
        channel_offset (int): Desired channel offset.
        model_output (list, optional): List of arrays of model outputs. Defaults to [].
        model_channels (list, optional): List of lists of strings of channel names model output is based on. Defaults to [].
        use_slider (bool, optional): Whether or not to activate view-slider. Defaults to False.

    Returns:
        plotly.graph_objs.Figure: Plot of EEG data.
    &#34;&#34;&#34;
    fig = Figure()
    
    plotting_data = _get_plotting_data(raw, file_name, selected_channel_names, EEG_scale, channel_offset, model_output, model_channels)
    globals.plotting_data = plotting_data.copy()    
    
    fig = get_EEG_plot(plotting_data, globals.x0, globals.x1, use_slider=use_slider)

    return fig</code></pre>
</details>
</dd>
<dt id="RV.helperfunctions.visualization_helperfunctions.get_EEG_plot"><code class="name flex">
<span>def <span class="ident">get_EEG_plot</span></span>(<span>plotting_data, x0, x1, use_slider=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates EEG plots.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plotting_data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dict holding all relevant data from raw object and model outputs for plotting.</dd>
<dt><strong><code>x0</code></strong> :&ensp;<code>float</code></dt>
<dd>X-coordinate (in sec) to start plot.</dd>
<dt><strong><code>x1</code></strong> :&ensp;<code>float</code></dt>
<dd>X-coordinate (in sec) to end plot.</dd>
<dt><strong><code>use_slider</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether or not to activate view-slider. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly.graph_objs.Figure</code></dt>
<dd>Plot of EEG data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_EEG_plot(plotting_data, x0, x1, use_slider=False):
    &#34;&#34;&#34;Generates EEG plots.

    Args:
        plotting_data (dict): Dict holding all relevant data from raw object and model outputs for plotting.
        x0 (float): X-coordinate (in sec) to start plot.
        x1 (float): X-coordinate (in sec) to end plot.
        use_slider (bool, optional): Whether or not to activate view-slider. Defaults to False.

    Returns:
        plotly.graph_objs.Figure: Plot of EEG data.
    &#34;&#34;&#34;
    fig = Figure()
    
    index_0 = None
    index_1 = None
    
    for index, timepoint in enumerate(plotting_data[&#39;EEG&#39;][&#39;timescale&#39;]):
        if timepoint &gt; x0:
            index_0 = index
            break
        
    for index, timepoint in enumerate(plotting_data[&#39;EEG&#39;][&#39;timescale&#39;]):
        if timepoint &gt; x1:
            index_1 = index
            break
    
    for channel_index in range(plotting_data[&#39;EEG&#39;][&#39;offset_EEG_data&#39;].shape[1]):      
        fig.add_trace(
            Scattergl(
                x=plotting_data[&#39;EEG&#39;][&#39;timescale&#39;][index_0:index_1],
                y=plotting_data[&#39;EEG&#39;][&#39;offset_EEG_data&#39;][index_0:index_1, channel_index],
                marker=dict(color=plotting_data[&#39;EEG&#39;][&#39;default_channel_colors&#39;][channel_index], size=0.1),
                name=plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;][channel_index],
                customdata=plotting_data[&#39;EEG&#39;][&#39;EEG_data&#39;][index_0:index_1, channel_index] * plotting_data[&#39;EEG&#39;][&#39;scaling_factor&#39;],  # y-data without offset
                hovertemplate=&#39;&lt;b&gt;%{fullData.name}&lt;/b&gt; | Time (in sec)=%{x:.2f}, Amplitude (in μV)=%{customdata:.3f}&#39; + &#39;&lt;extra&gt;&lt;/extra&gt;&#39; if not plotting_data[&#39;EEG&#39;][&#39;scaling_factor&#39;] else &#39;&lt;b&gt;%{fullData.name}&lt;/b&gt; | Time (in sec)=%{x:.2f}, Amplitude (scaled)=%{customdata:.3f}&#39; + &#39;&lt;extra&gt;&lt;/extra&gt;&#39;,
                mode=&#39;lines+markers&#39;
            )
        )

    model_index_0 = None
    model_index_1 = None

    # Model predictions
    for model_index in range(len(plotting_data[&#39;model&#39;])):
        for index, timepoint in enumerate(plotting_data[&#39;model&#39;][model_index][&#39;model_timescale&#39;]):
            if timepoint &gt; x0:
                model_index_0 = index
                break
            
        for index, timepoint in enumerate(plotting_data[&#39;model&#39;][model_index][&#39;model_timescale&#39;]):
            if timepoint &gt; x1:
                model_index_1 = index
                break

        fig.add_trace(
            Scattergl(
                x=plotting_data[&#39;model&#39;][model_index][&#39;model_timescale&#39;][model_index_0:model_index_1],
                y=plotting_data[&#39;model&#39;][model_index][&#39;offset_model_data&#39;][model_index_0:model_index_1],
                marker=dict(
                    size=10,
                    cmax=1,
                    cmin=0,
                    color=plotting_data[&#39;model&#39;][model_index][&#39;model_data&#39;][model_index_0:model_index_1],
                    # colorbar=dict(
                    #     title=&#39;Colorbar&#39;,
                    #     yanchor=&#34;top&#34;, 
                    #     y=1, 
                    #     x=1
                    # ),
                    colorscale=&#39;RdBu_r&#39;
                ),
                name=&#39;M{}&#39;.format(model_index),
                mode=&#39;markers&#39;,
                customdata=plotting_data[&#39;model&#39;][model_index][&#39;model_data&#39;][model_index_0:model_index_1],
                hovertemplate=&#39;Time=%{x:.2f}, Prediction=%{customdata:.2f}&lt;extra&gt;&lt;b&gt;%{fullData.name}&lt;/b&gt;&lt;/extra&gt;&#39;
            )
        )
    
    longest_channel_name_length = len(max(plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;], key=len))

    fig.update_layout(
        plot_bgcolor=&#39;#fafafa&#39;,
        paper_bgcolor=&#39;#dfdfdf&#39;,
        title=dict(
            text=plotting_data[&#39;EEG&#39;][&#39;file_name&#39;],
            y=0.98,
            x=0.5 if not plotting_data[&#39;model&#39;] else 0.6,
            xanchor=&#39;center&#39;,
            yanchor=&#39;top&#39;
        ),
        xaxis=dict(
            # title_text=&#39;Time (in sec)&#39;,
            rangeslider=dict(
                visible=True if use_slider else False,
                thickness=0.04
            ),
            type=&#34;linear&#34;,
        ),

        legend=dict(
            # itemwidth=30
            # orientation=&#34;h&#34;,
            # yanchor=&#34;bottom&#34;,
            # y=1,
            # xanchor=&#34;left&#34;,
            x=1.01
        ),

        autosize=False,
        margin=dict(
            autoexpand=False,
            l=longest_channel_name_length * 6 + 15,  #30
            r=longest_channel_name_length * 6 + 80,  #115
            # b=0,
            t=50,
            pad=5,
        ),

        dragmode=&#39;drawrect&#39;,
        newshape=dict(
            fillcolor=&#39;red&#39;,
            opacity=0.6,
            drawdirection=&#39;vertical&#39;,
            layer=&#39;below&#39;,
            line_width=0
        ),
    )

    fig.update_yaxes(
        tickmode=&#39;array&#39;,
        tickvals=plotting_data[&#39;plot&#39;][&#39;y_ticks&#39;],
        ticktext=plotting_data[&#39;plot&#39;][&#39;y_tick_labels&#39;],
        showgrid=False,
        zeroline=False,
        fixedrange=False,
        range=((-(2 + len(plotting_data[&#39;model&#39;])) * (c.DEFAULT_Y_AXIS_OFFSET)), ((len(plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;]) + 1) * (c.DEFAULT_Y_AXIS_OFFSET)))  # Start y-axis range to cut off peaks
    )
    fig.update_xaxes(
        # title_text=&#39;Time (in sec)&#39;
        showgrid=True,
        zeroline=False,
        constrain=&#39;domain&#39;,
        range=(x0, x1) if not use_slider else (x0, x0 + 11),  # Start x-axis range to show approx. 10 seconds
    )

    # Add annotations
    marked_annotations = get_annotations(globals.raw)

    print(marked_annotations)
    
    for annotation in marked_annotations:
        # if not ((annotation[0] &lt; globals.x0 and annotation[1] &lt; globals.x0) or (annotation[0] &gt; globals.x1 and annotation[1] &gt; globals.x1)):
        fig.add_vrect(
            editable=True,
            x0=annotation[0],
            x1=annotation[1],
            fillcolor=&#39;red&#39;,
            opacity=0.6,
            layer=&#39;below&#39;,
            line_width=0
        )
    
    if plotting_data[&#39;model&#39;]:
        plotting_data[&#39;EEG&#39;][&#39;default_channel_colors&#39;][-1] = plotting_data[&#39;EEG&#39;][&#39;default_channel_colors&#39;][-1][index_0:index_1]
        plotting_data[&#39;EEG&#39;][&#39;highlighted_channel_colors&#39;][-1] = plotting_data[&#39;EEG&#39;][&#39;highlighted_channel_colors&#39;][-1][index_0:index_1]
    
    fig.update_layout(
        updatemenus=list([
            dict(
                buttons=list([
                    dict(label=&#34;Reset time-axis&#34;,  
                        method=&#34;relayout&#34;, 
                        args=[{
                            &#34;xaxis.range[0]&#34;: x0,
                            &#34;xaxis.range[1]&#34;: x1 if not use_slider else x0 + 11,
                        }]
                    ),
                    dict(label=&#34;Reset channel-axis&#34;,  
                        method=&#34;relayout&#34;, 
                        args=[{
                            &#34;yaxis.range[0]&#34;: (-(2 + len(plotting_data[&#39;model&#39;])) * (c.DEFAULT_Y_AXIS_OFFSET)),
                            &#34;yaxis.range[1]&#34;: ((len(plotting_data[&#39;EEG&#39;][&#39;channel_names&#39;]) + 1) * (c.DEFAULT_Y_AXIS_OFFSET))
                        }]
                    ),
                    dict(label=&#39;Hide/show bad channels&#39;,
                        method=&#39;restyle&#39;,
                        args2=[{&#39;visible&#39;: True}],
                        args=[{&#39;visible&#39;: plotting_data[&#39;EEG&#39;][&#39;channel_visibility&#39;]}]
                    ),
                    dict(label=&#39;Highlight model-channels&#39;,
                        method=&#39;restyle&#39;,
                        args2=[{&#39;marker.color&#39;: plotting_data[&#39;EEG&#39;][&#39;default_channel_colors&#39;]}],
                        args=[{&#39;marker.color&#39;: plotting_data[&#39;EEG&#39;][&#39;highlighted_channel_colors&#39;]}],
                        visible=True if plotting_data[&#39;model&#39;] else False
                    ),
                ]),
                direction = &#39;left&#39;,
                # active=4,
                # pad = {&#39;l&#39;: 100, &#39;t&#39;: 10},
                showactive = False,
                type = &#39;buttons&#39;,
                xanchor = &#39;left&#39;,
                yanchor = &#39;top&#39;,
                x = 0,
                y = 1.08,
                bgcolor = &#39;#fafafa&#39;,
                bordercolor = &#39;#c7c7c7&#39;
            )
        ])
    )

    return fig</code></pre>
</details>
</dd>
<dt id="RV.helperfunctions.visualization_helperfunctions.get_channel_locations_plot"><code class="name flex">
<span>def <span class="ident">get_channel_locations_plot</span></span>(<span>raw)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates channel-topography plot of given raw object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>raw</code></strong> :&ensp;<code>mne.io.Raw</code></dt>
<dd>Raw object to get channel locations from.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly.graph_objs.Figure</code></dt>
<dd>Plot of channel-topography.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channel_locations_plot(raw):
    &#34;&#34;&#34;Generates channel-topography plot of given raw object.

    Args:
        raw (mne.io.Raw): Raw object to get channel locations from.

    Returns:
        plotly.graph_objs.Figure: Plot of channel-topography.
    &#34;&#34;&#34;
    # Get channel locations through MNE
    if raw.info[&#39;dig&#39;]:
        pos, outlines = _get_pos_outlines(raw.info, np.arange(len(raw.info[&#39;chs&#39;])), &#39;auto&#39;)
        
        head_coordinates = outlines[&#39;mask_pos&#39;]
        head_markers = []
        head_markers.append(min(head_coordinates[0]))
        head_markers.append(max(head_coordinates[0]))
        head_markers.append(min(head_coordinates[1]))
        head_markers.append(max(head_coordinates[1]))
        print(head_markers)
    else:
        pos = np.array([])
        outlines = []
        head_markers = []
    # print(pos)
    print(outlines)
    
    chs = raw.info[&#39;chs&#39;]
    channel_coordinates = pos  # np.empty((len(chs), 2))  # manual
    channel_names = []

    for index, channel in enumerate(chs):
        # channel_coordinates[index] = channel[&#39;loc&#39;][:2]  # manual
        channel_names.append(channel[&#39;ch_name&#39;])

    # Optional to scale channel locations
    # channel_coordinates = channel_coordinates * 1000

    topography_plot = Figure()

    if channel_coordinates.size &gt; 0:
        for channel in range(len(channel_names)):
            topography_plot.add_trace(
                Scattergl(
                    x=[channel_coordinates[channel, 0]],
                    y=[channel_coordinates[channel, 1]],
                    customdata=[channel_names[channel]],
                    mode=&#34;markers+text&#34;,
                    name=channel_names[channel],
                    text=channel_names[channel],
                    textposition=&#34;bottom center&#34; if channel_coordinates[channel, 1] &lt;= 0 else &#39;top center&#39;,
                    hovertemplate=&#39;&lt;b&gt;%{fullData.name}&lt;/b&gt;&#39; + &#39;&lt;extra&gt;&lt;/extra&gt;&#39;,
                    # marker=dict(color=&#39;#4796c5&#39;)
                )
            )
        
        if head_markers:
            topography_plot.add_shape(
                type=&#34;circle&#34;,
                xref=&#34;x&#34;,
                yref=&#34;y&#34;,
                x0=head_markers[0],
                x1=head_markers[1],
                y0=head_markers[2],
                y1=head_markers[3],
                line_color=&#34;black&#34;,
            )

    topography_plot.update_layout(
        dragmode=&#39;select&#39;,
        showlegend=False,
        clickmode=&#39;event+select&#39;
    )
    
    topography_plot.update_yaxes(
        scaleanchor = &#34;x&#34;,
        scaleratio = 1,
    )

    # topography_plot.update_xaxes(
    #     # title_text=&#39;Time (in sec)&#39;
    #     # showgrid=True,
    #     # zeroline=False,
    #     # constrain=&#39;domain&#39;,
    #     # range=(-0.2, 10.2),  # Start x-axis range to show approx. 10 seconds
    # )

    return topography_plot</code></pre>
</details>
</dd>
<dt id="RV.helperfunctions.visualization_helperfunctions.get_most_prominent_freq"><code class="name flex">
<span>def <span class="ident">get_most_prominent_freq</span></span>(<span>f, Pxx_den)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate most prominent frequency of selected data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>array</code></dt>
<dd>Sample frequencies.</dd>
<dt><strong><code>Pxx_den</code></strong> :&ensp;<code>array</code></dt>
<dd>Power densities.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Frequency with highest density.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_most_prominent_freq(f, Pxx_den):
    &#34;&#34;&#34;Calculate most prominent frequency of selected data.

    Args:
        f (array): Sample frequencies.
        Pxx_den (array): Power densities.

    Returns:
        float: Frequency with highest density.
    &#34;&#34;&#34;
    temp_list = Pxx_den.tolist()
    maximum_peak = temp_list.index(Pxx_den.max())
    maximum_peak_value = f[maximum_peak]
    # print(maximum_peak_value)

    return maximum_peak_value</code></pre>
</details>
</dd>
<dt id="RV.helperfunctions.visualization_helperfunctions.get_power_spectrum_plot"><code class="name flex">
<span>def <span class="ident">get_power_spectrum_plot</span></span>(<span>f, Pxx_den)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates power spectrum plot.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f</code></strong> :&ensp;<code>array</code></dt>
<dd>Sample frequencies.</dd>
<dt><strong><code>Pxx_den</code></strong> :&ensp;<code>array</code></dt>
<dd>Power densities.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>plotly.graph_objs.Figure</code></dt>
<dd>Plot of power spectrum.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_power_spectrum_plot(f, Pxx_den):
    &#34;&#34;&#34;Generates power spectrum plot.

    Args:
        f (array): Sample frequencies.
        Pxx_den (array): Power densities.

    Returns:
        plotly.graph_objs.Figure: Plot of power spectrum.
    &#34;&#34;&#34;
    fig = Figure()

    fig.add_trace(
        Scattergl(
            x=f,
            y=Pxx_den,
            hovertemplate=&#39;Frequency (in Hz)=%{x:.2f}, Power density=%{y:.2f}&#39; + &#39;&lt;extra&gt;&lt;/extra&gt;&#39;,
            marker=dict(color=&#39;#4796c5&#39;)
        )
    )

    fig.update_layout(
        xaxis=dict(
            title_text=&#39;Frequencies (in Hz)&#39;,
        ),
        yaxis=dict(
            title_text=&#39;Power density&#39;
        ),
    )

    return fig</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="RV.helperfunctions" href="index.html">RV.helperfunctions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="RV.helperfunctions.visualization_helperfunctions.calc_power_spectrum" href="#RV.helperfunctions.visualization_helperfunctions.calc_power_spectrum">calc_power_spectrum</a></code></li>
<li><code><a title="RV.helperfunctions.visualization_helperfunctions.get_EEG_figure" href="#RV.helperfunctions.visualization_helperfunctions.get_EEG_figure">get_EEG_figure</a></code></li>
<li><code><a title="RV.helperfunctions.visualization_helperfunctions.get_EEG_plot" href="#RV.helperfunctions.visualization_helperfunctions.get_EEG_plot">get_EEG_plot</a></code></li>
<li><code><a title="RV.helperfunctions.visualization_helperfunctions.get_channel_locations_plot" href="#RV.helperfunctions.visualization_helperfunctions.get_channel_locations_plot">get_channel_locations_plot</a></code></li>
<li><code><a title="RV.helperfunctions.visualization_helperfunctions.get_most_prominent_freq" href="#RV.helperfunctions.visualization_helperfunctions.get_most_prominent_freq">get_most_prominent_freq</a></code></li>
<li><code><a title="RV.helperfunctions.visualization_helperfunctions.get_power_spectrum_plot" href="#RV.helperfunctions.visualization_helperfunctions.get_power_spectrum_plot">get_power_spectrum_plot</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>